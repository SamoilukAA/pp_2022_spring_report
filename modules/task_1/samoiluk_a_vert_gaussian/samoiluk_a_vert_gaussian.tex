\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Линейная фильтрация изображений (горизонтальное разбиение). Ядро Гаусса 3x3.»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381908-1 \\ Самойлюк А. А.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par В обработке изображений гауссово размытие является результатом размытия изображения гауссовой функцией (названной в честь математика и ученого Карла Фридриха Гаусса).
\par Это широко используемый эффект в графическом программном обеспечении, как правило, для уменьшения шума изображения и уменьшения детализации. Визуальный эффект этого метода размытия представляет собой плавное размытие, напоминающее просмотр изображения через полупрозрачный экран, отчетливо отличающийся от эффекта боке, создаваемого не в фокусе объектива или тенью объекта при обычном освещении.
\par Гауссово сглаживание также используется в качестве этапа предварительной обработки в алгоритмах компьютерного зрения для улучшения структуры изображений в разных масштабах.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par Требуется выполнить следующие задачи:
\begin{enumerate}
    \item Реализовать последовательную версию программы с применением фильтра Гаусса для обработки изображения.
    \item Реализовать параллельные версии программы с применением фильтра Гаусса для обработки изображения с использованием технологий OpenMP, Intel TBB и std::thread.
    \item Реализовать программу с визуализацией результатов фильтра Гаусса с использованием библиотеки OpenCV.
    \item Провести эксперименты для оценки эффективности выполненных реализаций.
\end{enumerate}
\par 
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Алгоритм написан для одноканальных изображений в оттенках серого.
\par Алгоритм фильтра Гаусса состоит из нескольких шагов:
\begin{enumerate}
  \item Создание матрицы изображения и заполнение ее случайными значениями от нуля до 255.
  \item Создание двумерного ядра Гаусса $G_{\sigma}$ со стандартным отклонением $\sigma$, определяемым как:
  $$ G_{\sigma}=\frac{1}{2\pi\sigma}\exp^{-\frac{x^2+y^2}{2\sigma^2}} $$
  \item Вычисление нового значения пикселя изображения путем наложения ядра Гаусса на соответсвующую область, то есть значение каждого пикселя получается средневзвешенным значением самого себя и других значений пикселей в окрестности.
  \item Запись полученных значений в результирующую матрицу.
\end{enumerate}
\par Для программы с визуализацией результатов фильтра Гаусса появляются дополнительные шаги:
\begin{enumerate}
    \item Загрузка изображения и получение доступа к значениям его пикселей.
    \item Преобразование получившейся матрицы обратно в изображение.
    \item Отображение исходнго изображения и прошедшего фильтрацию на экран.
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par Распараллеливание происходит в момент вычисления нового значения пикселя, которое производится во вложенном цикле. Исходная матрица делится между потоками по столбцам, каждый поток получает свою собственную область.
\par В случае использования технологии OpenMp для распараллеливания внутреннего цикла используется директива \textsl{\#pragma omp parallel for}. После этой директивы итерации цикла распределяются между потоками и выполняются параллельно. Такое распараллеливание возможно, поскольку между итерациями цикла нет информационной зависимости.
\par При использовании технологии Intel TBB для распараллеливания цикла используется  шаблонная функция tbb::parallel\_for, где первый параметр - одномерное итерационное пространство tbb::blocked\_range, которое задает диапазон в виде полуинтервала по количесву столбцов, второй параметр - лямбда-выражение, где происходит вычисление нового значеня пикселя, которое в качестве параметра получает часть итерационного пространства.
\par В технологиях OpenMp и Intel TBB распределение пространства между потоками происходит автоматически.
\par При использовании std::thread, для каждого потока вычисляется количество итераций цикла для каждого потока. Для этого количество столбцов матрицы изображения делится на количество потоков (в данном случае, количество одновременных потоков, поддерживаемых системой). Для каждого потока вычисляются начальное услословие (\textsl{start = i * size}) и условие выхода из цикла (\textsl{finish = start + size}), где \textsl{i} - номер потока, \textsl{size} - количество итераций. Эти значения передаются в качестве параметров в лямбда-выражение, где происходит вычисление нового значения пикселя.
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из заголовочного файла vert\_gaussian.h и двух файлов исходного кода vert\_gaussian.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для последовательного и параллельных методов обработки изображения, прототип функции для создания ядра Гаусса и несколько прототипов вспомогательных функций, таких как создание матрицы изображения со случайными значениями и сравнение двух матриц между собой.
\par Создание ядра Гаусса:
\begin{lstlisting}
std::vector<std::vector<double>> createGaussian();
\end{lstlisting}
\par Возвращает матрицу размера 3x3 со значениями типа double.
\par Функция для последовательной обработки изображения:
\begin{lstlisting}
std::vector<std::vector<int>> GaussianFilter_Seq(
    const std::vector<std::vector<int>> &sourceImg);
\end{lstlisting}
\par В функцию передается исходное изображение. Возвращает обработанную матрицу.
\par Функция для параллельной обработки изображения:
\begin{lstlisting}
std::vector<std::vector<int>> GaussianFilter_Thread(
    const std::vector<std::vector<int>> &sourceImg);
\end{lstlisting}
\par В эту функцию также передается исходное изображение и возвращается обработанная матрица.
\par Из функций для последовательной и параллельной обработки изображения вызывается функция, где и происходит вычисление нового значения пикселя:
\begin{lstlisting}
int newPixelColor(const std::vector<std::vector<int>> &sourceImg,
    int x, int y, const std::vector<std::vector<double>> &kernel);
\end{lstlisting}
\par Первый параметр - исходное изображение, второй параметр - ядро Гаусса. Возвращаемое значение - новое значения пикселя.
\par Функция для создания матрицы изображения:
\begin{lstlisting}
std::vector<std::vector<int>> getRandomImg(int width, int height);
\end{lstlisting}
\par В нее передаются ширина и высота изображения. Возвращает матрицу изображения.
\par Функция для сравнения матриц:
\begin{lstlisting}
template<class T>
bool imgEquivalent(const std::vector<std::vector<T>> &sourceImg,
    const std::vector<std::vector<T>> &resultImg)
\end{lstlisting}
\par Она является шаблонной и возвращает  true , если значения матриц одинаковые, и  false, если они различны.
\par В файле vert\_gaussian.cpp содержатся реализации функций, объявленных в заголовочном файле. В файле main.cpp содержатся тесты для проверки корректности программы.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности работы программы были написаны тесты с помощью библиотеки для модульного тестирования Google Test. В частности тесты для проверки корректного создания ядра Гаусса, для проверки того, что изображение проходит фильтрацию, для сравнения результатов последовательного и параллельного алгоритмов, применненых к одному и тому же изображению. Тесты проводились на изображениях различных размеров, начиная с небольших (10х10), заканчивая большими (5000х5000), а также на изображениях с разными значениями ширины и высоты. Все тесты были пройдены успешно.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
\par Эксперименты для оценки эффективности проводились с использованием следующего оборудования и программного обеспечения:
\begin{itemize}
\item Процессор: Двухъядерный процессор AMD Ryzen 3 3200U with Radeon Vega Mobile Gfx 2.60 GHz (4 SMT-потока);
\item Оперативная память: 8,00 ГБ, DDR4, 1199,3 MHz;
\item Операционная система: Microsoft Windows 10;
\item Среда разработки, компилятор: Microsoft Visual Studio 2019, встроенный компилятор.
\end{itemize}
\par Эксперименты проводились для изображений различных размерв.
\par Тестирование проводилось на 4 потоках.
\par Результаты экспериментов представлены в таблицах.

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c матрицей 100х100}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.0101133       & -             \\
OpenMP          & 0.0112078       & 0.902345      \\
Intel TBB       & 0.0352715       & 0.266705      \\
std::thread     & 0.036           & 0.277778      \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c матрицей 500х500}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 0.339238       & -            \\
OpenMP          & 0.112112       & 3.02588      \\
Intel TBB       & 0.124773       & 2.67744      \\
std::thread     & 0.0115         & 2.97391      \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c матрицей 1000х1000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 1.19833       & -            \\
OpenMP          & 0.549255      & 2.18174      \\
Intel TBB       & 0.549135      & 2.3475       \\
std::thread     & 0.628         & 2.04299      \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов c матрицей 5000х5000}
\centering
\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
\hline
Версия алгоритма & Время работы & Ускорение  \\[5pt]
\hline
Sequential      & 25.7531       & -            \\
OpenMP          & 8.62005       & 2.98758      \\
Intel TBB       & 11.0358       & 2.39271      \\
std::thread     & 11.233        & 2.35948      \\
\hline
\end{tabular}
\end{table}
\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
\par Результаты экспериметнов показали, что параллельная реализация эффективна только тогда, когда время вычисления превышает накладные расходы, связанные с созданием и управлением несколькими потоками. То есть когда изображение достаточно большое.
\par Начиная с изображения размером 500х500 время параллельной реализации сокращается в более чем 2 раза. При этом можно заметить, что версия с использованием технологии Intel TBB работает несколько быстрее.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
\par В рамках данной лабораторной работы были реализованы последовательная версия программы с применением фильтра Гаусса для обработки изображения, паралелльные версии с использованием технологий OpenMP, Intel TBB и std::thread.
Проведенные тесты и визуализация результатов с помощью библиотеки OpenCV показали корректность реализованной задачи, а эксперименты - эффективность параллельных реализаций.
\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item Сысоев А.В. Параллельное программирование с использованием OpenMP. URL: \newline
\url{https://cloud.unn.ru/s/RQMgkKLMq92cm6A}
\item Мееров И.Б., Сысоев А.В., Сиднев А.А. Инструменты параллельного программирования для систем с общей памятью. Библиотека Intel Threading Building Blocks. URL: \newline
\url{https://cloud.unn.ru/s/nS8EtaeH7N4XW7t}
\item Фильтр Гаусса - Электронный ресурс. URL: \newline
\url{https://translated.turbopages.org/proxy_u/en-ru.ru.0b80e878-62912dbc-854d565b-74722d776562/https/en.wikipedia.org/wiki/Gaussian_blur}
\end{enumerate}
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\textbf{Последовательная версия}
\par vert\_gaussian.h
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#ifndef MODULES_TASK_1_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define MODULES_TASK_1_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define _USE_MATH_DEFINES

#include <vector>
#include<random>
#include<cmath>

std::vector<std::vector<double>> createGaussian();
std::vector<std::vector<int>> GaussianFilter(
    std::vector<std::vector<int>> &sourceImg);
int newPixelColor(std::vector<std::vector<int>> &sourceImg,
    int x, int y, std::vector<std::vector<double>> &kernel);
int checkValue(int value, int min, int max);
std::vector<std::vector<int>> getRandomImg(int width, int height);

template<class T>
bool imgEquivalent(std::vector<std::vector<T>> &sourceImg,
    std::vector<std::vector<T>> &resultImg) {
    int sourceW = sourceImg.size();
    int sourceH = sourceImg[0].size();
    int resultW = resultImg.size();
    int resultH = resultImg[0].size();

    if (sourceW != resultW || sourceH != resultH) return false;
    for (int i = 0; i < sourceW; i++) {
        for (int j = 0; j < sourceH; j++) {
            if (sourceImg[i][j] != resultImg[i][j])
                return false;
        }
    }
    return true;
}

#endif  // MODULES_TASK_1_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
\end{lstlisting}
\par vert\_gaussian.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya

#include "../../../modules/task_1/samoiluk_a_vert_gaussian/vert_gaussian.h"

const int min_pix = 0;
const int max_pix = 255;
const int radius = 1;
const double sigma = 1.0;

std::vector<std::vector<double>> createGaussian() {
    int size = 2 * radius + 1;
    std::vector<std::vector<double>> kernel(size, std::vector<double>(size));
    double norm = 0;

    for (int i = -radius; i <= radius; i++)
        for (int j = -radius; j <= radius; j++) {
            kernel[i + radius][j + radius] =
                exp(-(i * i + j * j) / (2 * sigma * sigma))
                   / (2 * M_PI * sigma * sigma);
            norm += kernel[i + radius][j + radius];
        }

    for (int i = 0; i < size; i++)
        for (int j = 0; j < size; j++)
            kernel[i][j] /= norm;
    return kernel;
}

std::vector<std::vector<int>> GaussianFilter(
    std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    for (std::vector<int>::size_type i = 0; i < sourceImg.size(); i++) {
        for (std::vector<int>::size_type j = 0; j < sourceImg[0].size(); j++) {
            resultImg[i][j] = newPixelColor(sourceImg, i, j, kernel);
        }
    }
    return resultImg;
}

int newPixelColor(std::vector<std::vector<int>> &sourceImg, int x,
    int y, std::vector<std::vector<double>> &kernel) {
    double result = 0;
    int width = sourceImg.size();
    int height = sourceImg[0].size();
    for (int j = -radius; j <= radius; j++)
        for (int i = -radius; i <= radius; i++) {
            int idX = checkValue(x + i, 0, width - 1);
            int idY = checkValue(y + j, 0, height - 1);
            int neighborColor = sourceImg[idX][idY];
            result += neighborColor * kernel[i + radius][j + radius];
        }
    return checkValue(static_cast<int>(result), min_pix, max_pix);
}

int checkValue(int value, int min, int max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

std::vector<std::vector<int>> getRandomImg(int width, int height) {
    if (width < 1 || height < 1)
        throw "Wrong size";
    std::vector<std::vector<int>> matrix(width, std::vector<int>(height));
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int i = 0; i < width; i++) {
        for (int j = 0; j < height; j++)
            matrix[i][j] = static_cast<int>(gen() % max_pix);
    }
    return matrix;
}
\end{lstlisting}
\par main.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include <gtest/gtest.h>
#include "./vert_gaussian.h"

TEST(Gaussian, can_create_matrix) {
    std::vector<std::vector<int>> img;

    ASSERT_NO_THROW(img = getRandomImg(10, 10));
}

TEST(Gaussian, cant_create_matrix_with_wrong_size) {
    std::vector<std::vector<int>> img;

    ASSERT_ANY_THROW(img = getRandomImg(0, 20));
    ASSERT_ANY_THROW(img = getRandomImg(15, 0));
    ASSERT_ANY_THROW(img = getRandomImg(-5, -5));
}

TEST(Gaussian, can_create_kernel) {
    std::vector<std::vector<double>> sourceKernel =
    { { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 },
      { 0.12384140315297398, 0.20417995557165811,  0.12384140315297398 },
      { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 } };

    std::vector<std::vector<double>> kernel = createGaussian();

    EXPECT_TRUE(imgEquivalent(sourceKernel, kernel));
}

TEST(Gaussian, can_process_image_1) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(30, 30);
    std::vector<std::vector<int>> resultImg = GaussianFilter(sourceImg);

    EXPECT_FALSE(imgEquivalent(sourceImg, resultImg));
}

TEST(Gaussian, can_process_image_2) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(15, 45);
    std::vector<std::vector<int>> resultImg = GaussianFilter(sourceImg);

    EXPECT_FALSE(imgEquivalent(sourceImg, resultImg));
}

TEST(Gaussian, can_process_image_correctly) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(10, 10);
    std::vector<std::vector<int>> resultImg1 = GaussianFilter(sourceImg);
    std::vector<std::vector<int>> resultImg2 = GaussianFilter(sourceImg);

    EXPECT_TRUE(imgEquivalent(resultImg1, resultImg2));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}
\newpage

\textbf{OpenMP версия}
\par vert\_gaussian.h
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#ifndef MODULES_TASK_2_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define MODULES_TASK_2_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define _USE_MATH_DEFINES

#include<omp.h>
#include <vector>
#include<random>
#include<cmath>

std::vector<std::vector<double>> createGaussian();
std::vector<std::vector<int>> GaussianFilter_Seq(
    std::vector<std::vector<int>> &sourceImg);
std::vector<std::vector<int>> GaussianFilter_Par(
    std::vector<std::vector<int>> &sourceImg);
int newPixelColor(std::vector<std::vector<int>> &sourceImg,
    int x, int y, std::vector<std::vector<double>> &kernel);
int checkValue(int value, int min, int max);
std::vector<std::vector<int>> getRandomImg(int width, int height);

template<class T>
bool imgEquivalent(std::vector<std::vector<T>> &sourceImg,
    std::vector<std::vector<T>> &resultImg) {
    int sourceW = sourceImg.size();
    int sourceH = sourceImg[0].size();
    int resultW = resultImg.size();
    int resultH = resultImg[0].size();

    if (sourceW != resultW || sourceH != resultH) return false;
    for (int i = 0; i < sourceW; i++) {
        for (int j = 0; j < sourceH; j++) {
            if (sourceImg[i][j] != resultImg[i][j])
                return false;
        }
    }
    return true;
}

#endif  // MODULES_TASK_2_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
\end{lstlisting}
\par vert\_gaussian.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include "../../../modules/task_2/samoiluk_a_vert_gaussian/vert_gaussian.h"

const int min_pix = 0;
const int max_pix = 255;
const int radius = 1;
const double sigma = 1.0;

std::vector<std::vector<double>> createGaussian() {
    int size = 2 * radius + 1;
    std::vector<std::vector<double>> kernel(size, std::vector<double>(size));
    double norm = 0;

    for (int i = -radius; i <= radius; i++)
        for (int j = -radius; j <= radius; j++) {
            kernel[i + radius][j + radius] =
                exp(-(i * i + j * j) / (2 * sigma * sigma))
                / (2 * M_PI * sigma * sigma);
            norm += kernel[i + radius][j + radius];
        }

    for (int i = 0; i < size; i++)
        for (int j = 0; j < size; j++)
            kernel[i][j] /= norm;
    return kernel;
}

std::vector<std::vector<int>> GaussianFilter_Seq(
    std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    for (std::vector<int>::size_type i = 0; i < sourceImg.size(); i++) {
        for (std::vector<int>::size_type j = 0; j < sourceImg[0].size(); j++) {
            resultImg[i][j] = newPixelColor(sourceImg, i, j, kernel);
        }
    }
    return resultImg;
}

std::vector<std::vector<int>> GaussianFilter_Par(
    std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

#pragma omp parallel for
    for (int i = 0; i < static_cast<int>(sourceImg.size()); i++) {
        for (std::vector<int>::size_type j = 0; j < sourceImg[0].size(); j++) {
            resultImg[i][j] = newPixelColor(sourceImg, i, j, kernel);
        }
    }
    return resultImg;
}

int newPixelColor(std::vector<std::vector<int>> &sourceImg, int x,
    int y, std::vector<std::vector<double>> &kernel) {
    double result = 0;
    int width = sourceImg.size();
    int height = sourceImg[0].size();
    for (int j = -radius; j <= radius; j++)
        for (int i = -radius; i <= radius; i++) {
            int idX = checkValue(x + i, 0, width - 1);
            int idY = checkValue(y + j, 0, height - 1);
            int neighborColor = sourceImg[idX][idY];
            result += neighborColor * kernel[i + radius][j + radius];
        }
    return checkValue(static_cast<int>(result), min_pix, max_pix);
}

int checkValue(int value, int min, int max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

std::vector<std::vector<int>> getRandomImg(int width, int height) {
    if (width < 1 || height < 1)
        throw "Wrong size";
    std::vector<std::vector<int>> matrix(width, std::vector<int>(height));
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int i = 0; i < width; i++) {
        for (int j = 0; j < height; j++)
            matrix[i][j] = static_cast<int>(gen() % max_pix);
    }
    return matrix;
}
\end{lstlisting}
\par main.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include <gtest/gtest.h>
#include "./vert_gaussian.h"

TEST(Gaussian, can_create_matrix) {
    std::vector<std::vector<int>> img;

    ASSERT_NO_THROW(img = getRandomImg(10, 10));
}

TEST(Gaussian, cant_create_matrix_with_wrong_size) {
    std::vector<std::vector<int>> img;

    ASSERT_ANY_THROW(img = getRandomImg(0, 20));
    ASSERT_ANY_THROW(img = getRandomImg(15, 0));
    ASSERT_ANY_THROW(img = getRandomImg(-5, -5));
}

TEST(Gaussian, can_create_kernel) {
    std::vector<std::vector<double>> sourceKernel =
    { { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 },
      { 0.12384140315297398, 0.20417995557165811,  0.12384140315297398 },
      { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 } };

    std::vector<std::vector<double>> kernel = createGaussian();

    EXPECT_TRUE(imgEquivalent(sourceKernel, kernel));
}

TEST(Gaussian, can_process_image_1) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(10, 10);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_2) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(20, 20);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_3) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(30, 30);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_4) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(40, 40);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_5) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(100, 100);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_6) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(500, 500);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_7) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(50, 100);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_1000x1000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(1000, 1000);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_5000x5000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(5000, 5000);

    double t_start, dt_1, dt_2;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = omp_get_wtime() - t_start;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = omp_get_wtime();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Par(sourceImg);
    dt_2 = omp_get_wtime() - t_start;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}
\newpage

\textbf{TBB версия}
\par vert\_gaussian.h
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#ifndef MODULES_TASK_3_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define MODULES_TASK_3_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define _USE_MATH_DEFINES

#include<tbb/tbb.h>
#include <vector>
#include<random>
#include<cmath>

std::vector<std::vector<double>> createGaussian();
std::vector<std::vector<int>> GaussianFilter_Seq(
    std::vector<std::vector<int>> &sourceImg);
std::vector<std::vector<int>> GaussianFilter_Tbb(
    std::vector<std::vector<int>> &sourceImg);
int newPixelColor(std::vector<std::vector<int>> &sourceImg,
    int x, int y, std::vector<std::vector<double>> &kernel);
int checkValue(int value, int min, int max);
std::vector<std::vector<int>> getRandomImg(int width, int height);

template<class T>
bool imgEquivalent(std::vector<std::vector<T>> &sourceImg,
    std::vector<std::vector<T>> &resultImg) {
    int sourceW = sourceImg.size();
    int sourceH = sourceImg[0].size();
    int resultW = resultImg.size();
    int resultH = resultImg[0].size();

    if (sourceW != resultW || sourceH != resultH) return false;
    for (int i = 0; i < sourceW; i++) {
        for (int j = 0; j < sourceH; j++) {
            if (sourceImg[i][j] != resultImg[i][j])
                return false;
        }
    }
    return true;
}

#endif  // MODULES_TASK_3_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
\end{lstlisting}
\par vert\_gaussian.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include "../../../modules/task_3/samoiluk_a_vert_gaussian/vert_gaussian.h"

const int min_pix = 0;
const int max_pix = 255;
const int radius = 1;
const double sigma = 1.0;

std::vector<std::vector<double>> createGaussian() {
    int size = 2 * radius + 1;
    std::vector<std::vector<double>> kernel(size, std::vector<double>(size));
    double norm = 0;

    for (int i = -radius; i <= radius; i++)
        for (int j = -radius; j <= radius; j++) {
            kernel[i + radius][j + radius] =
                exp(-(i * i + j * j) / (2 * sigma * sigma))
                / (2 * M_PI * sigma * sigma);
            norm += kernel[i + radius][j + radius];
        }

    for (int i = 0; i < size; i++)
        for (int j = 0; j < size; j++)
            kernel[i][j] /= norm;
    return kernel;
}

std::vector<std::vector<int>> GaussianFilter_Seq(
    std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    for (std::vector<int>::size_type i = 0; i < sourceImg.size(); i++) {
        for (std::vector<int>::size_type j = 0; j < sourceImg[0].size(); j++) {
            resultImg[i][j] = newPixelColor(sourceImg, i, j, kernel);
        }
    }
    return resultImg;
}

std::vector<std::vector<int>> GaussianFilter_Tbb(
    std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    tbb::parallel_for(
        tbb::blocked_range<int>(0, static_cast<int>(sourceImg[0].size())),
            [&](const tbb::blocked_range<int>& r) {
                for (int j = r.begin(); j < r.end(); j++) {
                    for (std::vector<int>::size_type i = 0;
                        i < sourceImg.size(); i++) {
                        resultImg[i][j] =
                            newPixelColor(sourceImg, i, j, kernel);
                    }
                }
            });
    return resultImg;
}

int newPixelColor(std::vector<std::vector<int>> &sourceImg, int x,
    int y, std::vector<std::vector<double>> &kernel) {
    double result = 0;
    int width = sourceImg.size();
    int height = sourceImg[0].size();
    for (int j = -radius; j <= radius; j++)
        for (int i = -radius; i <= radius; i++) {
            int idX = checkValue(x + i, 0, width - 1);
            int idY = checkValue(y + j, 0, height - 1);
            int neighborColor = sourceImg[idX][idY];
            result += neighborColor * kernel[i + radius][j + radius];
        }
    return checkValue(static_cast<int>(result), min_pix, max_pix);
}

int checkValue(int value, int min, int max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

std::vector<std::vector<int>> getRandomImg(int width, int height) {
    if (width < 1 || height < 1)
        throw "Wrong size";
    std::vector<std::vector<int>> matrix(width, std::vector<int>(height));
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int i = 0; i < width; i++) {
        for (int j = 0; j < height; j++)
            matrix[i][j] = static_cast<int>(gen() % max_pix);
    }
    return matrix;
}
\end{lstlisting}
\par main.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include <gtest/gtest.h>
#include "./vert_gaussian.h"

TEST(Gaussian, can_create_matrix) {
    std::vector<std::vector<int>> img;

    ASSERT_NO_THROW(img = getRandomImg(10, 10));
}

TEST(Gaussian, cant_create_matrix_with_wrong_size) {
    std::vector<std::vector<int>> img;

    ASSERT_ANY_THROW(img = getRandomImg(0, 20));
    ASSERT_ANY_THROW(img = getRandomImg(15, 0));
    ASSERT_ANY_THROW(img = getRandomImg(-5, -5));
}

TEST(Gaussian, can_create_kernel) {
    std::vector<std::vector<double>> sourceKernel =
    { { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 },
      { 0.12384140315297398, 0.20417995557165811,  0.12384140315297398 },
      { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 } };

    std::vector<std::vector<double>> kernel = createGaussian();

    EXPECT_TRUE(imgEquivalent(sourceKernel, kernel));
}

TEST(Gaussian, can_process_image_1) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(10, 10);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_2) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(20, 20);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_3) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(30, 30);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_4) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(40, 40);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_5) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(100, 100);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_6) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(50, 100);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_500x500) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(500, 500);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_1000x1000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(1000, 1000);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_5000x5000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(5000, 5000);

    tbb::tick_count t_start;
    double dt_1, dt_2;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = tbb::tick_count::now();
    std::vector<std::vector<int>> resultImg_par = GaussianFilter_Tbb(sourceImg);
    dt_2 = (tbb::tick_count::now() - t_start).seconds();
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}
\newpage

\textbf{STD версия}
\par vert\_gaussian.h
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#ifndef MODULES_TASK_4_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define MODULES_TASK_4_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
#define _USE_MATH_DEFINES

#include <vector>
#include<random>
#include<cmath>
#include <ctime>
#include "../../3rdparty/unapproved/unapproved.h"

std::vector<std::vector<double>> createGaussian();
std::vector<std::vector<int>> GaussianFilter_Seq(
    const std::vector<std::vector<int>> &sourceImg);
std::vector<std::vector<int>> GaussianFilter_Thread(
    const std::vector<std::vector<int>> &sourceImg);
int newPixelColor(const std::vector<std::vector<int>> &sourceImg,
    int x, int y, const std::vector<std::vector<double>> &kernel);
int checkValue(int value, int min, int max);
std::vector<std::vector<int>> getRandomImg(int width, int height);

template<class T>
bool imgEquivalent(const std::vector<std::vector<T>> &sourceImg,
    const std::vector<std::vector<T>> &resultImg) {
    int sourceW = sourceImg.size();
    int sourceH = sourceImg[0].size();
    int resultW = resultImg.size();
    int resultH = resultImg[0].size();

    if (sourceW != resultW || sourceH != resultH) return false;
    for (int i = 0; i < sourceW; i++) {
        for (int j = 0; j < sourceH; j++) {
            if (sourceImg[i][j] != resultImg[i][j])
                return false;
        }
    }
    return true;
}

#endif  // MODULES_TASK_4_SAMOILUK_A_VERT_GAUSSIAN_VERT_GAUSSIAN_H_
\end{lstlisting}
\par vert\_gaussian.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include "../../../modules/task_4/samoiluk_a_vert_gaussian/vert_gaussian.h"

const int min_pix = 0;
const int max_pix = 255;
const int radius = 1;
const double sigma = 1.0;

std::vector<std::vector<double>> createGaussian() {
    int size = 2 * radius + 1;
    std::vector<std::vector<double>> kernel(size, std::vector<double>(size));
    double norm = 0;

    for (int i = -radius; i <= radius; i++)
        for (int j = -radius; j <= radius; j++) {
            kernel[i + radius][j + radius] =
                exp(-(i * i + j * j) / (2 * sigma * sigma))
                / (2 * M_PI * sigma * sigma);
            norm += kernel[i + radius][j + radius];
        }

    for (int i = 0; i < size; i++)
        for (int j = 0; j < size; j++)
            kernel[i][j] /= norm;
    return kernel;
}

std::vector<std::vector<int>> GaussianFilter_Seq(
    const std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    for (std::vector<int>::size_type i = 0; i < sourceImg.size(); i++) {
        for (std::vector<int>::size_type j = 0; j < sourceImg[0].size(); j++) {
            resultImg[i][j] = newPixelColor(sourceImg, i, j, kernel);
        }
    }
    return resultImg;
}

std::vector<std::vector<int>> GaussianFilter_Thread(
    const std::vector<std::vector<int>> &sourceImg) {
    std::vector<std::vector<int>> resultImg(sourceImg.size(),
        std::vector<int>(sourceImg[0].size()));

    std::vector<std::vector<double>> kernel = createGaussian();

    int thread_num = std::thread::hardware_concurrency();
    std::vector<std::thread> threads(thread_num);

    int start, finish;
    int size = sourceImg[0].size() / thread_num;
    int rem = sourceImg[0].size() % thread_num;
    for (int i = 0; i < thread_num; i++) {
        start = i * size;
        finish = start + size;
        if (i == thread_num - 1) {
            finish += rem;
        }
        threads[i] = std::thread(
            [&](int start, int finish) {
                for (int j = start; j < finish; j++) {
                    for (std::vector<int>::size_type i = 0;
                            i < sourceImg.size(); i++) {
                        resultImg[i][j] =
                            newPixelColor(sourceImg, i, j, kernel);
                    }
                }
            }, start, finish);
    }

    for (int i = 0; i < thread_num; i++) {
        threads[i].join();
    }

    return resultImg;
}

int newPixelColor(const std::vector<std::vector<int>> &sourceImg, int x,
    int y, const std::vector<std::vector<double>> &kernel) {
    double result = 0;
    int width = sourceImg.size();
    int height = sourceImg[0].size();
    for (int j = -radius; j <= radius; j++)
        for (int i = -radius; i <= radius; i++) {
            int idX = checkValue(x + i, 0, width - 1);
            int idY = checkValue(y + j, 0, height - 1);
            int neighborColor = sourceImg[idX][idY];
            result += neighborColor * kernel[i + radius][j + radius];
        }
    return checkValue(static_cast<int>(result), min_pix, max_pix);
}

int checkValue(int value, int min, int max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

std::vector<std::vector<int>> getRandomImg(int width, int height) {
    if (width < 1 || height < 1)
        throw "Wrong size";
    std::vector<std::vector<int>> matrix(width, std::vector<int>(height));
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int i = 0; i < width; i++) {
        for (int j = 0; j < height; j++)
            matrix[i][j] = static_cast<int>(gen() % max_pix);
    }
    return matrix;
}
\end{lstlisting}
\par main.cpp
\begin{lstlisting}
// Copyright 2022 Samoiluk Anastasiya
#include <gtest/gtest.h>
#include "./vert_gaussian.h"

TEST(Gaussian, can_create_matrix) {
    std::vector<std::vector<int>> img;

    ASSERT_NO_THROW(img = getRandomImg(10, 10));
}

TEST(Gaussian, cant_create_matrix_with_wrong_size) {
    std::vector<std::vector<int>> img;

    ASSERT_ANY_THROW(img = getRandomImg(0, 20));
    ASSERT_ANY_THROW(img = getRandomImg(15, 0));
    ASSERT_ANY_THROW(img = getRandomImg(-5, -5));
}

TEST(Gaussian, can_create_kernel) {
    std::vector<std::vector<double>> sourceKernel =
    { { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 },
      { 0.12384140315297398, 0.20417995557165811,  0.12384140315297398 },
      { 0.075113607954111511, 0.12384140315297398, 0.075113607954111511 } };

    std::vector<std::vector<double>> kernel = createGaussian();

    EXPECT_TRUE(imgEquivalent(sourceKernel, kernel));
}

TEST(Gaussian, can_process_image_1) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(10, 10);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_2) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(20, 20);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_3) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(30, 30);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_4) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(40, 40);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_5) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(100, 100);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, can_process_image_6) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(50, 100);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_500x500) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(500, 500);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_1000x1000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(1000, 1000);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

TEST(Gaussian, big_image_5000x5000) {
    std::vector<std::vector<int>> sourceImg = getRandomImg(5000, 5000);

    clock_t t_start;
    double dt_1, dt_2;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_seq = GaussianFilter_Seq(sourceImg);
    dt_1 = (clock() - t_start) / 1000.0;
    std::cout << "Sequential time = " << dt_1 << std::endl;

    t_start = clock();
    std::vector<std::vector<int>> resultImg_par =
        GaussianFilter_Thread(sourceImg);
    dt_2 = (clock() - t_start) / 1000.0;
    std::cout << "Parallel time = " << dt_2 << std::endl;

    std::cout << "eff = " << dt_1 / dt_2;

    EXPECT_TRUE(imgEquivalent(resultImg_seq, resultImg_par));
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}
\end{document}
